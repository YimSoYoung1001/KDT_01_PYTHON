# ---------------------------------------------------------------------- 
# set 데이터 타입
# - 제일 마지막에 추가된 타입
# - 목적 : 중복 데이터 제거
# - 특징 : 이미 존재하는 데이터는 저장하지 않음!!
# - 문법 : [데이터1, 데이터2, ... , 데이터N]
# -----------------------------------------------------------------------
# 빈 데이터 타입 생성 ======================================================
aList = []
aTuple = ()
aDict = {}
aSet = set()  #set이라는 함수로 생성 가능
aStr = ''

print(f'aList => {type(aList)}, {len(aList)}개')
print(f'aTuple => {type(aTuple)}, {len(aTuple)}개')
print(f'aDict => {type(aDict)}, {len(aDict)}개')
print(f'aSet => {type(aSet)}, {len(aSet)}개')
print(f'aStr => {type(aStr)}, {len(aStr)}개')

print('==========================')

# ------------------------------------------------------------------------
# 생성자 함수 => 타입 이름과 동일한 함수명
# - 힙 영역에 메모리 공간 잡고 데이터 초기화 기능을 수행
# ------------------------------------------------------------------------
aList = list()
aTuple = tuple()
aDict = dict()
aSet = set()
print(f'aList => {type(aList)}, {len(aList)}개')
print(f'aTuple => {type(aTuple)}, {len(aTuple)}개')
print(f'aDict => {type(aDict)}, {len(aDict)}개')
print(f'aSet => {type(aSet)}, {len(aSet)}개')

'''
타입명 동일한 함수명
- list 타입     list()
- tuple 타입    tuple()
- dict 타입     dict()
- set 타입      set()
- str 타입      " "
'''
print()



# -----------------------------------------------------------------------------------
# set 타입의 데이터 생성
# -----------------------------------------------------------------------------------
a1 = {1,1,2,3,4,5,1,1,1,1}
a2 = [1,1,2,3,4,5,1,1,1,1]

print(f'a1 => {type(a1)}, {len(a1)}개')
print(f'a2 => {type(a2)}, {len(a2)}개')

# 다른 데이터 타입에서 중복 데이터 제거 시에 활용  ==> 형변환!!
a2 = list(set(a2))
print(f'a2 => {type(a2)}, {len(a2)}개')


# -------------------------------------------------------------------------------------
# set 타입의 연산 수행
# -------------------------------------------------------------------------------------
a1 = {1,3,5,1,2}
b1 = {1,2,3,4,5,6,7,8,9,10}
#set는 시퀀스가 없는 형태이다. 리스트와 튜플은 시퀀스가 있음
#print(a1 + b1) #set끼리는 더하기가 불가능 (시퀀스가 없어서)

a1 = list(a1)
b1 = list(b1)
print(a1 + b1)

print(a1 * 2) #중복되니까 불가능
print()

# -------------------------------------------------------------------------------------
# 원소/요소 읽기/수정/삭제/추가   ===> 인덱스X, 키X  ===> 메서드 제공
# -------------------------------------------------------------------------------------
a1 = set(a1)
# 원소/요소 추가 => 1개 추가 : add()메서드
a1.add(10)
a1.add(10)
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')

a1.add('A')
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')

# 여러개의 원소/요소 추가 => update() 메서드
a1.update([11,22,33,44])     #이거는 실행할때마다 순서가 바뀜 set은 순서와 관련없으니까
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')

a1.update("Good Luck !!")
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')   #따로따로 들어감

a1.add("Good Luck !!")
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')   #덩어리로 들어감


# 원소/요소 삭제 => remove(데이터)
a1.remove('G')
print(f'remove a1 => {type(a1)}, {len(a1)}개, {a1}') #없는걸 없애려고 하면 error발생

a1.discard('G')
print(f'discard a1 => {type(a1)}, {len(a1)}개, {a1}') #없는 걸 없애려고 해도 ㄱㅊ


# 원소/요소 꺼내기 => pop(데이터)
data = a1.pop()
print(f'a1 => {data}, {type(a1)}, {len(a1)}개, {a1}')


# ---------------------------------------------------------------------------
# 집합에 관련된 메서드들과 기호 / 연산자
# ---------------------------------------------------------------------------
# 교집합 ---------------------------------------------------------------------
# - 여러개의 집합에 공통으로 존재하는 데이터만 추출
# - 기호/연산자 : &   and연산자
# - 메서드 : intersection()
a1.clear()
a1.update("Happy")
print(f'a1 ==> {a1}')

a2 = a1.intersection({'a', 'A', 'p'})
print(f'a2  =>  {a2}')
print(f'a1.intersection({"a","A","p"}) => {a1.intersection({"a","A","p"})}')


# 합집합 ----------------------------------------------------------------------
# - 여러 개의 집합에서 중복은 1개만 포함한 모든 원소의 집합
# - 기호/연산자 : |   or연산자
# - 메서드 : union()
# ----------------------------------------------------------------------------
a2 = a1.union({'a', 'A', 'p'})
print(f"a2  =>  {a2} , a1 | {'a', 'A', 'p'}")


# 차집합 ----------------------------------------------------------------------
# - 교집합 데이터 제외한 나머지 데이터
# - 기호/연산자 : -   뺄셈연산자
# - 메서드 : difference()
# ----------------------------------------------------------------------------
a2 = a1.difference({"a","A","p"})
print(f"a2  =>  {a2} , a1 - {'a', 'A', 'p'}")

a3 = {"a","A","p"}.difference(a1)
print(f"a3  =>  {a3} ,{'a', 'A', 'p'} - a1")


# 정렬 -----------------------------------------------------------------------
# => 원소 값을 서로 비교해서 작은 데이터 -> 큰 데이터 순서로 저장 ==> 오름차순 정렬
# => 원소 값을 서로 비교해서 큰 데이터 -> 작은 데이터 순서로 저장 ==> 내림차순 정렬
# => set 타입에는 정렬 메서드 없음 ==> 내장함수 sorted()
#    set는 sort함수 적용 불가능
# ---------------------------------------------------------------------------
a1 = sorted(a1)
print(f' a1 => {type(a1)}, {a1} ')

